class process_llm_rule_checker : public rule_base<process_event>
{
private:
    std::string llm_server_url;
    std::vector<tracker_event<process_event>> event_buffer;
    std::mutex buffer_mutex;
    std::mutex response_mutex;
    std::string last_response;
    std::condition_variable cond_var;
    const size_t buffer_limit = 100; // 可调整大小
    const std::chrono::seconds flush_interval = std::chrono::seconds(5); // 每5秒刷新一次
    std::thread flush_thread;
    bool stop_thread = false;

    json buildDataToSend(const std::vector<tracker_event<process_event>>& event_buffer);
    std::string sendDataToLLM(const json& data);
    static size_t writeCallback(void* contents, size_t size, size_t nmemb, void* userp);
    std::string parseLLMResponse(const std::string& response);

    void flush_buffer() {
        while (!stop_thread) {
            std::unique_lock<std::mutex> lock(buffer_mutex);
            cond_var.wait_for(lock, flush_interval, [this] { return event_buffer.size() >= buffer_limit || stop_thread; });
            if (event_buffer.empty()) continue;

            // 打包并发送数据到LLM
            json data = buildDataToSend(event_buffer);
            std::string response = sendDataToLLM(data);
            {
                std::lock_guard<std::mutex> resp_lock(response_mutex);
                last_response =parseLLMResponse(response); // 更新存储的响应
            }
            event_buffer.clear();
        }
    }
    

public:
  virtual ~process_llm_rule_checker() {
    stop_thread = true;      // 设置停止标志
    cond_var.notify_all();   // 通知所有等待的线程
    if (flush_thread.joinable()) {
        flush_thread.join(); // 等待线程结束
    }}
    process_llm_rule_checker(std::shared_ptr<sec_analyzer> analyzer_ptr) : rule_base(analyzer_ptr), flush_thread(&process_llm_rule_checker::flush_buffer, this) {
        std::cout << "llm_rule_checker created" << std::endl;
    }
  int check_rule(const tracker_event<process_event>&e, rule_message &msg);
};